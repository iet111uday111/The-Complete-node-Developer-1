WEBVTT

00:00.270 --> 00:06.490
In this video you're going to learn about promises now promises are available in javascript sense yes.

00:06.490 --> 00:11.400
Six although they have been around in third party libraries for quite some time but they finally made

00:11.400 --> 00:16.830
their way into the core javascript language which is great because they're a really fantastic feature

00:17.250 --> 00:22.170
promises aim to solve a lot of the problems that come up when you have a lot of asynchronous code in

00:22.170 --> 00:26.910
your application and then make it a lot easier to manage your asynchronous computations.

00:27.030 --> 00:32.400
Things like requesting data from a database or in the case of the weather app things like fetching data

00:32.460 --> 00:34.560
from you are out down below.

00:34.560 --> 00:37.050
We do a similar thing using callbacks.

00:37.060 --> 00:38.700
Here we have two callbacks.

00:38.700 --> 00:44.160
One that gets passed into your code address and one that gets passed in to get whether we use this to

00:44.160 --> 00:50.980
manage our asynchronous actions in our case it's things like fetching data from an API using an HTP

00:51.000 --> 00:51.820
request.

00:51.930 --> 00:56.050
We can use promises in this example to make the code a lot nicer.

00:56.130 --> 00:58.530
And that's exactly what the aim is going to be a little later.

00:58.530 --> 01:01.210
For now though we're going to explore the very basics.

01:01.320 --> 01:06.450
I'm not going to compare and contrast callbacks versus promises just yet because there's a lot more

01:06.450 --> 01:11.250
subtleties than can be described without knowing exactly how promises work.

01:11.250 --> 01:16.530
So what I'd like to do before we even talk about why they're better is go ahead and simply create some

01:16.860 --> 01:21.690
over inside of the playground folder we're going to do that and we're going to call this file promise

01:22.080 --> 01:28.000
dot J as before we define promises and talk about exactly how they work.

01:28.000 --> 01:32.770
I want to go ahead and just run through a simple example because I find that is the best way to learn

01:32.770 --> 01:36.500
just about anything going through an example and seeing how it works.

01:36.610 --> 01:41.290
We'll learn a little bit about how promises work and we'll start to understand exactly why they're useful

01:41.320 --> 01:45.300
why they've even come to exist inside of javascript to get started.

01:45.400 --> 01:48.280
We're going to work through a very very basic example.

01:48.310 --> 01:49.990
We're not going to do anything complex.

01:49.990 --> 01:54.940
We're going to stick to the core promise features to get started with this very simple example.

01:54.940 --> 01:57.680
I'm going to make a variable called some promise.

01:57.790 --> 02:00.500
This is going to eventually store the promised object.

02:00.520 --> 02:05.710
We'll be calling various methods on this to do something with the promise we're going to set the some

02:05.710 --> 02:11.740
promise variable equal to the return result from the constructor function for promises we're going to

02:11.740 --> 02:16.540
use the new keyword to create a new instance of a promise and then we're going to provide the thing

02:16.540 --> 02:20.380
we want to create a new instance of promise with a capital P..

02:20.860 --> 02:24.720
Now this promise function which is indeed a function you have to call it like one.

02:24.730 --> 02:26.500
It takes one argument.

02:26.500 --> 02:31.930
This argument is going to be a function I'm going to use an anonymous arrow function and inside of here

02:31.960 --> 02:34.600
we're going to do all of the asynchronous stuff we want to do.

02:34.660 --> 02:40.720
It's all going to be abstracted kind of like we extract the HTP request inside of this geocoder address

02:40.720 --> 02:41.360
function.

02:41.620 --> 02:47.260
All of the complex logic in here does indeed need to happen but the opt out file doesn't need to worry

02:47.260 --> 02:47.950
about it.

02:47.950 --> 02:53.110
Opt-Out J us has a very very simple statement that checks if there's an error and if there is we print

02:53.110 --> 02:58.090
a message if there's not great we move on the same thing is going to be true with promises inside of

02:58.090 --> 02:58.530
here.

02:58.570 --> 03:00.090
We're going to do anything we need to do.

03:00.160 --> 03:02.650
That's going to be involved with that asynchronous action.

03:03.040 --> 03:09.170
This callback function is going to get called with two arguments resolve and reject.

03:09.460 --> 03:12.420
And this is how we're going to manage the state of our promise.

03:12.520 --> 03:16.690
When you make a promise you're making a promise you're saying hey I'm going to go off it I'm going to

03:16.690 --> 03:18.860
fetch that Web site data for you.

03:18.880 --> 03:24.850
Now this could go well in which case you would resolve the promise setting it state to fulfilled when

03:24.850 --> 03:29.260
a promise is fulfilled it's gone out and it's done the thing you've expected it to do.

03:29.260 --> 03:34.180
That could be a database request NHT request or something else completely.

03:34.180 --> 03:39.620
Now when you call reject you're saying hey we tried to get that thing done man but we just could not.

03:39.730 --> 03:42.200
So the promise has been considered rejected.

03:42.280 --> 03:48.600
Those are the two states that you can set a promise to fulfilled or rejected just like inside of geocoder

03:48.640 --> 03:49.300
Jay.

03:49.390 --> 03:54.880
We either provide one argument for an error or we provide that second argument if things went well instead

03:54.880 --> 04:00.430
of doing that though promises give us two functions we can call now in order to illustrate exactly how

04:00.430 --> 04:05.800
we can use these We're going to go ahead and call resolve once again this is not asynchronous we're

04:05.800 --> 04:07.350
not doing anything quite yet.

04:07.420 --> 04:11.670
So all of this is going to happen in essentially real time as far as you see in the terminal.

04:12.010 --> 04:15.770
We're going to call resolved with some data in this case I'm going to pass in a string.

04:15.910 --> 04:19.290
Hey it worked.

04:19.300 --> 04:23.260
Now this string this is the value the promise was fulfilled with.

04:23.290 --> 04:26.620
This is exactly what someone is going to get back in our case.

04:26.620 --> 04:29.610
It could be the data whether it's the results or the error message.

04:29.610 --> 04:31.890
In our case though we're using resolve.

04:31.900 --> 04:34.780
So this is going to be the actual data the user wanted.

04:34.810 --> 04:38.230
When things go well this is what they expected.

04:38.230 --> 04:43.300
Now you can only pass one argument to both resolve and reject which means if you want to provide multiple

04:43.300 --> 04:49.150
pieces of information I recommend resolving or rejecting an object that you can set multiple properties

04:49.150 --> 04:49.680
on.

04:49.750 --> 04:51.890
In our case though a simple message hey it works.

04:51.900 --> 04:53.280
We'll do the job.

04:53.620 --> 04:59.410
Now in order to actually do something when the promise gets either resolved or rejected we need to call

04:59.410 --> 05:07.960
a promise method called then some promise dot then and then lets us provide callback functions for both

05:07.960 --> 05:10.460
success cases and error cases.

05:10.540 --> 05:15.150
And this is one of the areas that callbacks differ from premises in a callback.

05:15.160 --> 05:17.670
We had one function that fired no matter what.

05:17.760 --> 05:23.270
And the arguments let us know whether or not things went well and promises were going to have two functions.

05:23.350 --> 05:27.180
And that is going to be what determines whether or not things went as planned.

05:27.190 --> 05:31.570
Now before we dive into adding two functions let's start with just one right here.

05:31.720 --> 05:34.710
I'm going to call then passing in one function.

05:34.720 --> 05:40.360
This function is only only only going to get called if the promise gets fulfilled meaning it works as

05:40.360 --> 05:46.060
expected when it does it's going to get called with the value passed to resolve in our case it's a simple

05:46.060 --> 05:50.030
message but it could be something like a user object.

05:50.060 --> 05:51.830
In the case of a database request.

05:51.950 --> 05:56.810
For now though we'll stick with message and we'll print that message to the screen right inside of the

05:56.810 --> 05:59.050
callback when the promise gets fulfilled.

05:59.060 --> 06:05.530
We're going to call cancel that log printing success and then as a second argument I'm going to print

06:05.530 --> 06:07.930
in the actual message variable.

06:08.110 --> 06:10.830
And now that we had a very basic premise example in place.

06:10.840 --> 06:15.700
Let's go ahead and run it from the terminal using gnomon which we installed in the previous section

06:16.190 --> 06:18.160
node man.

06:18.230 --> 06:20.290
Then we're going to go into the playground folder.

06:20.300 --> 06:23.280
Forward slash promis dot J as.

06:23.360 --> 06:27.430
When we do this right away our app runs and right away we get success.

06:27.440 --> 06:31.430
Hey it worked as you saw this happened instantaneously.

06:31.460 --> 06:35.020
There was no delay because we haven't done anything asynchronously.

06:35.060 --> 06:40.250
Now when we first explored callbacks we used set time out to simulate a delay and that's exactly what

06:40.250 --> 06:43.340
we're going to do here right inside of our function.

06:43.350 --> 06:49.750
I'm going to call set time out passing the two arguments the function to call after the delay and the

06:49.750 --> 06:51.400
delay in milliseconds.

06:51.400 --> 06:55.420
I'll go with two thousand five hundred which is two and a half seconds.

06:55.500 --> 07:00.790
Now after those two and a half seconds are up then and only then do we want to resolve the problems.

07:00.790 --> 07:06.100
This means that our function that when we pass into then this is not going to get called for two and

07:06.100 --> 07:10.860
a half seconds because as we know this is not going to get called until the promise resolves.

07:10.930 --> 07:15.910
I'm going to save the file which will restart gnomon over in the terminal you can see we have our delay

07:15.950 --> 07:17.140
and then success.

07:17.170 --> 07:17.970
Hey it worked.

07:17.980 --> 07:19.280
Prints to the screen.

07:19.390 --> 07:24.830
That two and a half second delay was caused by this set timed out and after the delay was up.

07:24.940 --> 07:26.510
In this case it's an artificial delay.

07:26.590 --> 07:28.330
But later it'll be a real delay.

07:28.360 --> 07:31.120
We're able to resolve with the data.

07:31.120 --> 07:33.090
Now there's a chance that things didn't go well.

07:33.100 --> 07:36.060
You have to handle errors inside of your node applications.

07:36.070 --> 07:38.280
In that case you wouldn't call resolve.

07:38.380 --> 07:39.900
You would call reject.

07:40.240 --> 07:45.540
Let's go ahead and comment out this resolve line and create a second one where we call Project.

07:45.820 --> 07:48.790
I'm going to call Project much the same way I called resolve.

07:48.800 --> 07:53.000
You have to pass in one argument and in this case a simple error message will do.

07:53.390 --> 08:01.350
Unable to fulfill promise not one we call reject.

08:01.450 --> 08:06.460
We're telling the promise that it has been rejected meaning the thing we tried to do did not go well

08:06.610 --> 08:09.340
and currently we don't have an argument that handles that.

08:09.390 --> 08:12.910
As you mentioned this function only gets called when things go as expected.

08:12.910 --> 08:14.390
Not when we have errors.

08:14.470 --> 08:20.020
If I save the file and rerun it over in the terminal what we're going to get is a promise that rejects

08:20.110 --> 08:23.240
but we don't have a handler for so nothing is going to print to the screen.

08:23.350 --> 08:25.200
And this is going to be a pretty big problem.

08:25.210 --> 08:29.560
What we need to do is do something with that error message maybe we want to alert the user or we want

08:29.560 --> 08:31.360
to try some other code here.

08:31.360 --> 08:37.210
You can see that nothing printed between the restarting and the exiting in order to do something with

08:37.210 --> 08:41.250
the error we're going to add a second argument to then this second argument.

08:41.260 --> 08:44.660
This is what lets us handle errors in our promises.

08:44.680 --> 08:49.870
This argument is going to get executed and called with that value in this case is our message.

08:50.080 --> 08:55.910
I'm going to create an argument called error message right here inside of here we can do something with

08:55.910 --> 09:01.190
that and this case will print it to the screen using console log printing error with a calling and a

09:01.190 --> 09:08.840
space to add some nice formatting followed by the actual value that was rejected error message.

09:09.120 --> 09:14.060
And now that we have this in place we can go ahead and refresh things by saving the file and we are

09:14.060 --> 09:18.680
going to see our error message over in the terminal because we now have a place for it to do something.

09:18.710 --> 09:23.270
In this case we have a place for it to print the message to the screen on able to fill promis prints

09:23.270 --> 09:25.640
to the screen which works exactly as expected.

09:25.640 --> 09:27.680
And this is fantastic.

09:27.710 --> 09:33.050
We don't have a promise that can either get resolved the rejected if it gets resolved meaning the promise

09:33.050 --> 09:33.890
was fulfilled.

09:33.980 --> 09:37.030
We have a function that handles that if it gets rejected.

09:37.130 --> 09:39.560
We have a function that handles that as well.

09:39.560 --> 09:42.230
And this is one of the reasons I really love promises.

09:42.230 --> 09:46.670
You're going to provide different functions depending on whether or not the promise got resolved the

09:46.670 --> 09:47.500
rejected.

09:47.540 --> 09:52.610
This lets you avoid a lot of the complex if statements inside of your code which we needed to do in.

09:52.660 --> 09:58.180
Yes to manage whether or not the actual callback succeeded or failed.

09:58.220 --> 10:03.410
Now inside of premise it's important to understand that you can only either resolve or reject a promise

10:03.440 --> 10:06.760
once if you resolve a promise you can't reject it later.

10:06.830 --> 10:11.140
And if you resolve that with one value you can't change your mind at a later point in time.

10:11.150 --> 10:16.220
For example if I have code like this where I resolve it first and then I reject we're going to get our

10:16.220 --> 10:20.900
success message printing to the screen and we're never going to see the error message because as I just

10:20.900 --> 10:26.960
said you can only do one of those actions once you can either resolve wants or you can reject once you

10:26.960 --> 10:29.780
can't do both and you can't do either twice.

10:29.810 --> 10:32.890
This is another great advantage over callbacks.

10:32.900 --> 10:37.460
There's nothing preventing us from accidentally calling the callback function twice.

10:37.460 --> 10:40.610
For example I could have another line right here.

10:40.610 --> 10:46.160
This is a more obvious example but it could easily be hidden inside of complex if else statements.

10:46.310 --> 10:52.310
And this case our callback function and J S is indeed going to get called twice which can cause really

10:52.310 --> 10:54.060
big problems for our program.

10:55.490 --> 10:58.200
Inside of the promise example this callback.

10:58.280 --> 11:00.170
It is never going to get called twice.

11:00.230 --> 11:05.390
No matter how many times you try to call resolver reject this function is only going to get fired once

11:05.630 --> 11:09.110
we can prove that right now by calling resolve again.

11:09.530 --> 11:14.000
In this case when I saved the file and refresh things we're going to resolve with our message hey it

11:14.000 --> 11:18.740
worked and we're never ever going to have the function fired a second time with no message because as

11:18.740 --> 11:24.170
we said the promise is already resolved once you set a promise is state to either fulfilled or rejected.

11:24.170 --> 11:26.130
You can't set it again.

11:26.150 --> 11:32.420
Now before a promise is resolved or object function gets called a promise is in a state which is known

11:32.420 --> 11:37.010
as pending meaning that you're waiting for information to come back or you're waiting for your async

11:37.040 --> 11:38.600
computation to finish.

11:38.630 --> 11:43.640
In our case while we're waiting for that weather data to come back the promise would be considered pending

11:44.000 --> 11:49.220
and a promise is considered settled when it has been either fulfilled or rejected.

11:49.220 --> 11:52.340
No matter which one you chose you could say that promise has settled.

11:52.340 --> 11:59.360
Meaning that it's no longer pending in our case this would be a settled promise that was indeed fulfilled

11:59.390 --> 12:02.000
because resolve is called right here.

12:02.000 --> 12:06.770
So those are just a couple of the benefits of promises you don't have to worry about having callbacks

12:06.770 --> 12:07.660
called twice.

12:07.760 --> 12:12.850
You can provide multiple functions one for success handling and one for error handling.

12:12.850 --> 12:19.650
It really is a fantastic utility and now that we've gone through a quick example of how promises work

12:19.790 --> 12:24.270
going over just the very fundamentals we're going to move on to something a slightly more complex and

12:24.270 --> 12:26.200
they'll also be a challenge for you.

12:26.280 --> 12:30.520
So you can learn how to create your own promises that is coming up in the next video.

12:30.540 --> 12:31.610
So stay tuned.

12:31.620 --> 12:33.340
I will see you then.
