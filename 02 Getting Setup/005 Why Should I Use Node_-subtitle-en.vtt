WEBVTT

00:01.250 --> 00:04.030
In this video we're going to cover the why behind it no.

00:04.120 --> 00:04.830
Yes.

00:04.890 --> 00:11.910
Why is it so good at creating back and apps and why is it becoming so popular with companies like Netflix

00:12.180 --> 00:14.230
Oubre and Wal-Mart all using knode.

00:14.340 --> 00:19.170
Yes in production as you might have noticed since you're taking this course when people want to learn

00:19.170 --> 00:23.210
a new back and language more and more they're turning to node as that language.

00:23.220 --> 00:29.160
They want to learn the nodes skill set is in hot demand for both front end developers who need to use

00:29.160 --> 00:35.700
know to day to day to do things like compile their applications to engineers who are creating applications

00:35.700 --> 00:37.710
and utilities using node.

00:37.830 --> 00:44.640
Yes all of this has made Noad the prime choice in 2016 as the back end language of choice.

00:44.670 --> 00:50.450
Now I've left this home page up for a reason in the last video we addressed the first sentence.

00:50.520 --> 00:56.140
We took a look at node j us and we learned that it's built on top of the V8 javascript engine.

00:56.190 --> 00:57.710
There's only three sentences here.

00:57.780 --> 01:00.620
So in this video we're going to take a look at the second two.

01:00.840 --> 01:02.400
We're going to go ahead and read them now.

01:02.410 --> 01:03.690
Then we'll break it down.

01:03.690 --> 01:06.410
We're learning exactly why node is so great.

01:06.720 --> 01:07.430
The first sentence.

01:07.440 --> 01:13.550
No genius uses an event driven non-blocking IO model that makes it lightweight and efficient.

01:13.560 --> 01:16.070
We're going to explore all of that in just a second.

01:16.080 --> 01:22.260
The second sentence which we'll explore at the end of the video noted Julius's package ecosystem NPM

01:22.440 --> 01:27.090
is the largest ecosystem of open source libraries in the world.

01:27.090 --> 01:30.530
Now these two sentences they have a ton of information packed into them.

01:30.540 --> 01:34.120
The second sentence has a lot more Pakhtun than the third.

01:34.230 --> 01:36.500
Well we're going to do is go over a few code examples.

01:36.510 --> 01:41.490
We're going to dive into some charts and graphs and we'll explore what makes no different and what makes

01:41.490 --> 01:46.270
it so great note is an event driven nonblocking language.

01:46.410 --> 01:48.820
Now you see non-blocking IO right here.

01:48.840 --> 01:49.920
What is I.

01:49.930 --> 01:55.290
Oh IO is something that your application does all of the time when you're reading or writing to a database

01:55.350 --> 01:56.350
that is I O.

01:56.370 --> 01:58.620
Which is short for input output.

01:58.650 --> 02:04.610
This is the communication from your node application to other things inside of the Internet of Things.

02:04.650 --> 02:07.010
This could be a database read and write request.

02:07.140 --> 02:13.950
You may be changing some files on your file system or maybe making an HTP request to a separate web

02:13.950 --> 02:19.640
server such as a Google API for fetching a map for the users current location.

02:19.800 --> 02:23.230
All of those use I O when IO takes time.

02:23.280 --> 02:25.510
Now the non-blocking IO is great.

02:25.560 --> 02:32.250
That means while one user is requesting a u r l from google other users can be requesting database file

02:32.260 --> 02:33.420
read and write access.

02:33.420 --> 02:38.780
They can be requesting all sorts of things without preventing anyone else from getting some work done.

02:39.090 --> 02:43.890
Let's go ahead and take a look at the difference between blocking and nonblocking software development

02:45.310 --> 02:45.830
right here.

02:45.840 --> 02:49.210
I have two files that we're going to be executing in just a minute.

02:49.210 --> 02:54.580
But for the moment we're going to explore how each operates the steps that are required in order for

02:54.580 --> 02:56.150
the program to finish.

02:56.290 --> 03:00.940
This is going to show us the big differences between blocking which I have on the left which is not

03:00.940 --> 03:06.760
what node uses and nonblocking on the right which is exactly how all of our node applications in the

03:06.760 --> 03:08.640
course are going to operate.

03:08.650 --> 03:13.690
You don't have to understand the individual details like what require is in order to understand what's

03:13.690 --> 03:14.580
going on here.

03:14.590 --> 03:18.640
We're going to be breaking things down in a very general sense.

03:18.700 --> 03:24.190
The first line on each is responsible for fetching a function that gets called and this function this

03:24.190 --> 03:30.640
is going to be our simulated I O function that is going to a database fetching some user data and printing

03:30.640 --> 03:31.700
it to the screen.

03:31.810 --> 03:35.140
Both files do the same thing they just do it in different ways.

03:35.230 --> 03:41.350
After we load in the function of both files try to fetch a user with an ID of one to three when it gets

03:41.350 --> 03:46.780
that user it prints it to the screen with the user one string before and then it goes on and it fetches

03:46.780 --> 03:47.550
the user with it.

03:47.550 --> 03:50.690
Three two one is the I.D. It prints that to the screen.

03:50.800 --> 03:54.020
And finally both files add up one plus.

03:54.190 --> 03:58.200
Storing the result which is three in the some variable and printing it to the screen.

03:58.480 --> 04:01.360
Now will they all do the same thing they do in very different ways.

04:01.360 --> 04:04.090
Let's break down the individual steps down below.

04:04.090 --> 04:09.670
We're going to go over what node executes and how long it takes you can consider these seconds it doesn't

04:09.670 --> 04:15.000
really matter it's just to show the relative operating speed between the two.

04:15.010 --> 04:20.560
The first thing that happens inside of our blocking example right here is we fetch the user on line

04:20.590 --> 04:21.400
3.

04:21.400 --> 04:28.290
Now this request requires us to go to a database which is an I O operation to fetch that user by ID.

04:28.330 --> 04:29.690
This takes a little bit of time.

04:29.800 --> 04:32.530
In our case and we're going to say it takes three seconds.

04:32.530 --> 04:38.770
Next online for we print the user to the screen which is not an operation and it runs right away printing

04:38.800 --> 04:40.210
user 1 to the screen.

04:40.210 --> 04:43.270
You can see that takes almost no time at all.

04:43.270 --> 04:49.290
Next up we go ahead and we wait on the fetching of a user to when user 2 comes back.

04:49.300 --> 04:55.550
As you might expect we print it to the screen which is exactly what happens on line 7 right here.

04:55.720 --> 04:59.450
Finally down below we add up our number and we print it to the screen.

04:59.620 --> 05:00.590
None of that is I.

05:00.610 --> 05:01.010
Oh.

05:01.030 --> 05:05.640
So right here we have are some printing to the screen in barely any time.

05:05.680 --> 05:07.660
This is how blocking works.

05:07.660 --> 05:12.330
It's called the blocking because well we're fetching from the database which is an IO operation.

05:12.340 --> 05:15.690
Our application cannot do anything else.

05:15.700 --> 05:20.830
This means our machine sits around idle waiting for the database to respond and can't even do something

05:20.830 --> 05:23.670
simple like adding two numbers and printing them to the screen.

05:23.680 --> 05:28.690
It's just not possible in a blocking system on the right.

05:28.690 --> 05:33.790
We have our nonblocking example this is how we're going to be building our node applications.

05:33.790 --> 05:39.350
Let's go ahead and break this down line by line first up things start much the same way.

05:39.410 --> 05:45.180
We're starting the get user function for user 1 which is exactly what we do here but we're not waiting.

05:45.320 --> 05:47.420
We're simply kicking off that event.

05:47.420 --> 05:53.340
This is all part of the event loop inside of know J S which is something we'll be exploring in detail.

05:53.390 --> 05:55.210
Notice it takes a little bit of time.

05:55.250 --> 05:58.890
We're just starting the request we're not waiting for that data.

05:59.060 --> 06:01.010
The next thing we do might surprise you.

06:01.040 --> 06:05.840
We're not printing user 1 to the screen because we're still waiting for that request to come back.

06:05.870 --> 06:11.150
Instead we start the process of fetching our user with the idea of three to one.

06:11.270 --> 06:14.870
Here we're kicking off another event which takes just a little bit of time to do.

06:14.870 --> 06:21.050
It is not an I O operation now behind the scenes the fetching of the database is IO but starting the

06:21.050 --> 06:22.940
event calling this function is not.

06:22.940 --> 06:25.130
So it happens really quickly.

06:25.130 --> 06:30.830
Next up we print the sum the sum doesn't care about either of the two user objects they're basically

06:30.860 --> 06:32.000
unrelated.

06:32.030 --> 06:38.810
So there's no need to wait for the users to come back before I print that some variable down below after

06:38.810 --> 06:39.630
we print the sum.

06:39.650 --> 06:42.830
What happens when we have this dotted box.

06:42.830 --> 06:47.410
This is the simulated time it takes for our event to get responded to.

06:47.420 --> 06:53.600
Now this box it is the exact same with as the box over here using nonblocking doesn't make our IO operations

06:53.600 --> 06:59.070
any faster but what it does do is it lets us run more than one operation at the same time.

06:59.090 --> 07:05.480
Here we start two IO operations before the half second to Mark and right here between three and three

07:05.480 --> 07:07.970
and a half seconds both come back.

07:07.970 --> 07:11.720
Now the result here is that the entire application finishes much quicker.

07:11.780 --> 07:17.240
The nonblocking version finished in just over three seconds while the blocking version takes just over

07:17.240 --> 07:17.850
six.

07:17.960 --> 07:24.350
A difference of 50 percent and that 50 percent comes from the fact that here we have two requests each

07:24.410 --> 07:29.120
taking three seconds and here we have two requests each taking three seconds.

07:29.180 --> 07:32.930
But they run at the same time using the nonblocking model.

07:32.930 --> 07:39.260
We can still do stuff like printing the sum without having to wait for our database to respond.

07:39.260 --> 07:41.190
Now this is the big difference between the two.

07:41.300 --> 07:47.480
Blocking everything happens in order and a nonblocking we start events attaching callbacks and these

07:47.480 --> 07:49.620
callbacks get fired later.

07:49.790 --> 07:54.650
We're still printing out user wan and user to we're just doing it when the data comes back because the

07:54.650 --> 08:01.850
data doesn't come back right away inside of no J as the event loop attaches a listener for the event

08:01.850 --> 08:02.640
to finish.

08:02.660 --> 08:07.820
In this case for that database to respond back when it does it calls the callback you pass in right

08:07.820 --> 08:10.560
here and then we print it to the screen.

08:11.730 --> 08:15.490
Now imagine this was a web server instead of the current example.

08:15.540 --> 08:20.640
That would mean if a web server comes in looking to query the database we can't process other users

08:20.640 --> 08:23.880
requests without spinning up a separate thread.

08:23.940 --> 08:29.460
Now no genius is single threaded which means your application runs on one single thread.

08:29.520 --> 08:34.110
But since we have non-blocking IO that's not a problem in a blocking context.

08:34.110 --> 08:37.560
We could handle two requests on two separate threads.

08:37.710 --> 08:42.750
But that doesn't really scale well because for each request we have to beef up the amount of CPQ and

08:42.750 --> 08:45.840
ram resources that we're using for the application.

08:46.080 --> 08:51.780
And this sucks because those threads they're still sitting idle just because we can spin up other threads

08:51.780 --> 08:52.770
doesn't mean we should.

08:52.770 --> 08:58.800
We're wasting resources that are doing nothing here instead of wasting resources by creating multiple

08:58.800 --> 08:59.520
threads.

08:59.520 --> 09:02.760
We're doing everything on one thread when a request comes in.

09:02.760 --> 09:04.390
The IO is non-blocking.

09:04.470 --> 09:09.270
So we're not taking up any more resources than we would be if it never happened at all.

09:09.270 --> 09:13.200
Let's go ahead and run these examples in real time and see what we get.

09:13.420 --> 09:18.750
And right here we have the two files that we saw over in the screen shot were going to be running both

09:18.750 --> 09:22.430
of these files and I'm using the Adam editor to edit my text files.

09:22.440 --> 09:25.090
These are things we're going to be setting up later in the section.

09:25.110 --> 09:27.300
This is just for your viewing purpose.

09:27.300 --> 09:30.760
You don't need to run these files so they're not provided.

09:30.810 --> 09:35.370
Now the blocking and non-blocking files they're both going to get run and they're going to do similar

09:35.370 --> 09:37.700
things obviously just in a different way.

09:37.770 --> 09:43.480
Both use IO operations get users sync and get used to that take 5 seconds apiece.

09:43.620 --> 09:45.140
The time is no different.

09:45.180 --> 09:49.950
It's just the order they execute it that makes the non-blocking version much quicker.

09:49.950 --> 09:55.590
Now to simulate and show how things work I'm going to add a few console dialog statements right here

09:56.190 --> 10:01.280
starting user 1 starting user 2.

10:01.460 --> 10:07.820
This is going to let us visualize how things work over inside of the terminal starting user to end starting.

10:07.820 --> 10:08.940
User 1.

10:09.170 --> 10:10.220
Perfect.

10:10.220 --> 10:14.840
Once again as I promised this is never going to come up again where you're just watching me magically

10:14.840 --> 10:16.430
create code.

10:16.700 --> 10:22.370
For now though we're going to start by running the blocking file over in the terminal by running node

10:22.760 --> 10:27.040
blocking J J.S. This is how we run files.

10:27.100 --> 10:32.740
We type node and we specify the file name when I run the file we get some output starting at User 1

10:32.800 --> 10:35.600
Prince to the screen and then it sits there.

10:35.600 --> 10:41.060
Now we have the user 1 object printing to the screen with the name Andrew and starting user to Prince

10:41.060 --> 10:42.020
to the screen.

10:42.080 --> 10:48.980
After that the user two object comes back around five seconds later with a name of gen are two users

10:48.980 --> 10:53.660
have printed to the screen and at the very end are some which is three prints to the screen.

10:53.660 --> 10:55.220
Everything works great.

10:55.220 --> 11:01.280
Notice that starting user one was immediately followed by the finishing of user 1 and starting user

11:01.280 --> 11:04.460
2 was immediately followed by the finishing of user 2.

11:04.580 --> 11:07.160
Because this is a blocking application.

11:07.160 --> 11:11.050
Now we're going to run the nonblocking file which I called nonblocking.

11:11.160 --> 11:17.840
Yes when I run this file starting user 1 prints starting user to print then some prints all back to

11:17.840 --> 11:24.920
back around 5 seconds later at basically the same time user one and user to both print to the screen.

11:24.930 --> 11:30.770
This is how nonblocking works just because we started an IO operation doesn't mean we can't do other

11:30.770 --> 11:34.830
things like starting another one and printing some data to the screen.

11:34.830 --> 11:36.270
In this case just a number.

11:36.350 --> 11:40.940
This is the big difference and this is what makes nonblocking apps so fantastic.

11:40.940 --> 11:46.790
They can do so many things at the exact same time without having to worry about the confusion of multi-threading

11:46.790 --> 11:48.030
applications.

11:48.290 --> 11:51.970
Let's go ahead and move back into the browser and take a look at the sentences again.

11:52.130 --> 11:57.250
Knode uses an event driven non-blocking IO model that makes that lightweight and efficient.

11:57.350 --> 12:03.410
And we just saw that in action because notas nonblocking we were able to cut down the time our application

12:03.410 --> 12:08.140
took by half this non-blocking IO makes our apps super quick.

12:08.160 --> 12:11.960
This is where the lightweight and efficient comes into play.

12:11.960 --> 12:18.350
Now let's go to the last sentence node's package ecosystem NPM is the largest ecosystem of open source

12:18.350 --> 12:19.760
libraries in the world.

12:19.760 --> 12:22.700
This is what really makes Noad fantastic.

12:22.700 --> 12:24.620
This is the cherry on top.

12:24.710 --> 12:30.750
The community that people every day developing new libraries that solve common problems in your know

12:30.790 --> 12:37.430
J.S. applications things like validating objects creating servers and serving up content live using

12:37.430 --> 12:38.170
sockets.

12:38.180 --> 12:40.360
There's libraries already built for all of those.

12:40.430 --> 12:42.170
So you don't have to worry about this.

12:42.200 --> 12:47.150
This means that you can focus on the specific things related to your application without having to create

12:47.150 --> 12:52.430
all this infrastructure before you can even write real code code that does something specific to your

12:52.430 --> 12:53.720
apps use.

12:53.840 --> 13:00.050
Now NPM which is available over on NPM A-J Eskridge is the site we're going to be turning to for a lot

13:00.050 --> 13:04.900
of third party modules if you're trying to solve a problem in node that sounds generic.

13:04.940 --> 13:07.430
Chances are someone's already solved it.

13:07.430 --> 13:12.740
For example if I want to validate some objects let's say I want to validate that a name property exists

13:12.800 --> 13:15.690
and that there's an ID with a length of three.

13:15.710 --> 13:17.880
I could go into Google or go into NPM.

13:17.930 --> 13:28.150
I usually choose Google and I could google and PM validate object when I google that I'm just going

13:28.150 --> 13:33.640
to look for results from NPM J ass dot com and here you can see the first three or so are from that

13:34.060 --> 13:35.440
I can click the first one.

13:35.440 --> 13:38.980
This is going to let me explore the documentation and see if it's right for me.

13:38.980 --> 13:42.070
This one looks great so I can add it to my app without any effort.

13:42.070 --> 13:43.570
Now we're going to be going through that process.

13:43.570 --> 13:47.420
Don't worry I'm not going to leave you high and dry on how to add third party modules.

13:47.560 --> 13:52.730
We're going to be using a ton of them in the course because this is what real no developers do.

13:52.750 --> 13:58.150
They take advantage of the fantastic community of developers and that's the last thing that makes node

13:58.210 --> 13:58.990
so great.

13:58.990 --> 14:04.570
This is why node has come to the position of power that it currently sits at because it's nonblocking

14:04.780 --> 14:10.220
meaning it's great for IO applications and it has a fantastic community of developers.

14:10.270 --> 14:14.950
So if you ever want to get anything done there's a chance someone already wrote the code to do it.

14:16.020 --> 14:21.520
This is not to say you should never use Rails or a python or any other blocking language again that

14:21.550 --> 14:22.810
is not what I'm getting at.

14:22.830 --> 14:27.060
What I'm really trying to show you is the power of no Jay ass and how you can make your applications

14:27.090 --> 14:33.770
even better languages like Python have things like the library twisted which aims to add non-blocking

14:33.900 --> 14:39.630
features to python though the big problem is all of the third party libraries those are still written

14:39.630 --> 14:41.100
in a blocking fashion.

14:41.100 --> 14:46.530
So you're really limited as to which libraries you can use since node was built nonblocking from the

14:46.530 --> 14:47.300
ground up.

14:47.370 --> 14:52.510
Every single library on NPM adjacent dot com is non-blocking.

14:52.560 --> 14:56.250
So you don't have to worry about finding one that's non-blocking verse blocking.

14:56.250 --> 15:01.550
You can install a module knowing it was built from the ground up using a non-blocking ideology.

15:01.770 --> 15:07.740
That is it for this to video series looking deep into what node is and why it's so great in the next

15:07.740 --> 15:08.570
couple of videos.

15:08.610 --> 15:11.700
You're going to be writing your very first app and running it from the terminal.

15:11.700 --> 15:12.690
So stay tuned.

15:12.750 --> 15:14.580
I am super excited to show you how
